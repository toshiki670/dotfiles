#!/bin/bash

# Constant
readonly CMDNAME=${0##*/}
readonly VERSION='1.0.0'

function usage() {
  cmdname_space=$(echo $CMDNAME | sed -e "s/./ /g")

  cat << __USAGE_TEXT__
Usage:
  $CMDNAME
  $CMDNAME [-v] [-h]
__USAGE_TEXT__
}

function description() {
  cat << __DESCRIPTION_TEXT__
Description:
  Remove duplicate entries from zsh history file.
  For duplicate commands, keeps only the most recent entry.

Example:
  $ ${CMDNAME}
    * Removes duplicates from ~/.zsh_history

Options:
  -h Show help
  -v Show version
__DESCRIPTION_TEXT__
}

function show_help() {
  usage
  echo
  description
}

# Option analysis
while getopts hv OPT
do
  case $OPT in
    "h" ) show_help >&1
          exit 0
          ;;
    "v" ) echo "$CMDNAME $VERSION"
          exit 0
          ;;
    # Invalid options
      * ) usage 1>&2
          exit 1 ;;
  esac
done
# Trim options from $*
shift $(($OPTIND - 1))

# Check if running in zsh or bash
if [[ -z "$HISTFILE" ]]; then
  HISTFILE="${HOME}/.zsh_history"
fi

if [[ ! -f "$HISTFILE" ]]; then
  echo "$CMDNAME: History file not found: $HISTFILE" 1>&2
  exit 1
fi

# Get original line count
original_count=$(wc -l < "$HISTFILE" | tr -d ' ')

# Create backup
backup_file="${HISTFILE}.backup.$(date +%Y%m%d_%H%M%S)"
cp "$HISTFILE" "$backup_file"
if [[ $? -ne 0 ]]; then
  echo "$CMDNAME: Failed to create backup." 1>&2
  exit 1
fi
echo "Backup created: $backup_file"
echo

# Use awk to deduplicate
# zsh history format: : timestamp:duration;command
# Strategy: Process from end to beginning (reverse order),
# keeping only the first occurrence of each command (which will be the most recent)
# This means old duplicates are removed, keeping the newest entry
temp_file=$(mktemp)

# Process history file in reverse order using awk
# Strategy: First combine multiline commands, then deduplicate
# zsh history format: : timestamp:duration;command
# Multiline commands: lines ending with \ are continuations
LC_ALL=C awk '
  BEGIN {
    entry_start = 0
    entry_lines = ""
    entry_count = 0
  }
  {
    # Check if this line starts a new entry (format: : timestamp:duration;command)
    if (/^:[0-9]+:[0-9]+;/) {
      # Save previous entry if exists
      if (entry_start > 0) {
        entry_count++
        entries[entry_count] = entry_lines
        entry_starts[entry_count] = entry_start
      }
      # Start new entry
      entry_start = NR
      entry_lines = $0
    } else {
      # Continuation of previous entry
      if (entry_start > 0) {
        entry_lines = entry_lines "\n" $0
      } else {
        # Orphan line (should not happen in valid history file)
        entry_count++
        entries[entry_count] = $0
        entry_starts[entry_count] = NR
        entry_start = NR
        entry_lines = $0
      }
    }
    # Store all lines for output
    lines[NR] = $0
  }
  END {
    # Save last entry
    if (entry_start > 0) {
      entry_count++
      entries[entry_count] = entry_lines
      entry_starts[entry_count] = entry_start
    }
    
    # Extract command from each entry and deduplicate
    for (i = entry_count; i >= 1; i--) {
      entry = entries[i]
      # Extract command part: everything after the first semicolon
      pos = index(entry, ";")
      if (pos > 0) {
        command = substr(entry, pos + 1)
      } else {
        command = entry
      }
      # Normalize command for comparison:
      # - Remove leading/trailing whitespace
      # - Normalize line endings (remove trailing backslashes before newlines)
      # - Collapse multiple spaces/tabs to single space
      gsub(/^[ \t]+|[ \t]+$/, "", command)
      # Remove trailing backslash-newline sequences (multiline continuation markers)
      gsub(/\\\n[ \t]*/, "\n", command)
      # Remove trailing backslashes (at end of command)
      gsub(/\\+$/, "", command)
      # Normalize whitespace: collapse multiple spaces/tabs to single space
      gsub(/[ \t]+/, " ", command)
      # Normalize newlines: collapse multiple newlines
      gsub(/\n+/, "\n", command)
      # Remove leading/trailing whitespace again after normalization
      gsub(/^[ \t\n]+|[ \t\n]+$/, "", command)
      
      # Keep only first occurrence (newest)
      if (command != "" && !seen[command]) {
        seen[command] = 1
        # Store entry info
        keep_count++
        keep_entries[keep_count] = entry
        keep_starts[keep_count] = entry_starts[i]
      }
    }
    
    # Output kept entries in original order (reverse to get chronological order)
    for (i = keep_count; i >= 1; i--) {
      print keep_entries[i]
    }
  }
' "$HISTFILE" > "$temp_file"

if [[ $? -ne 0 ]]; then
  echo "$CMDNAME: Failed to deduplicate history." 1>&2
  rm "$temp_file" "$backup_file"
  exit 1
fi

# Get new line count
new_count=$(wc -l < "$temp_file" | tr -d ' ')
removed_count=$((original_count - new_count))

if [[ $removed_count -eq 0 ]]; then
  echo "No duplicates found. History file is already deduplicated."
  rm "$temp_file" "$backup_file"
  exit 0
fi

echo "Found $removed_count duplicate entr$(if [[ $removed_count -eq 1 ]]; then echo "y"; else echo "ies"; fi)."
echo "Original entries: $original_count"
echo "After deduplication: $new_count"
echo

# Confirm
read -p "Remove duplicates? (y/n): " confirm
if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
  echo "$CMDNAME: Operation cancelled."
  rm "$temp_file" "$backup_file"
  exit 0
fi

# Replace history file
mv "$temp_file" "$HISTFILE"
if [[ $? -ne 0 ]]; then
  echo "$CMDNAME: Failed to update history file." 1>&2
  rm "$temp_file" "$backup_file"
  exit 1
fi

echo "Successfully removed $removed_count duplicate entr$(if [[ $removed_count -eq 1 ]]; then echo "y"; else echo "ies"; fi)."
echo "Backup saved at: $backup_file"

exit 0
