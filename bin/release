#!/bin/bash


# Constant
readonly CMDNAME=${0##*/}
readonly VERSION_FILE="VERSION"
readonly TRUE=1
readonly FALSE=0


function usage() {
  cmdname_space=$(echo $CMDNAME | sed -e "s/./ /g")

  cat << __USAGE_TEXT__
Usage:
  $CMDNAME <minor|patch> [--ci]
  $CMDNAME [-h]

__USAGE_TEXT__
}


function description() {
  cat << __DESCRIPTION_TEXT__
Description:
  Create a new release by bumping version and creating a GitHub release.

  - Reads current version from ${VERSION_FILE}
  - Bumps version based on release type (minor or patch)
  - Creates Git tag (v0.x.x format)
  - Creates GitHub Release with auto-generated notes
  - Commits version file update

Options:
  <minor|patch>  Release type:
                 minor: Bump minor version (0.x.0 -> 0.(x+1).0)
                 patch: Bump patch version (0.x.y -> 0.x.(y+1))
  --ci           Non-interactive mode for CI/CD (skip confirmation)
  -h             Show help
__DESCRIPTION_TEXT__
}


function show_help() {
  usage
  echo
  description
}


# Parse arguments
CI_MODE=$FALSE
RELEASE_TYPE=""

while [[ $# -gt 0 ]]; do
  case $1 in
    --ci)
      CI_MODE=$TRUE
      shift
      ;;
    -h|--help)
      show_help >&1
      exit 0
      ;;
    minor|patch)
      if [[ -n "$RELEASE_TYPE" ]]; then
        echo "${CMDNAME}: Multiple release types specified." 1>&2
        exit 1
      fi
      RELEASE_TYPE=$1
      shift
      ;;
    *)
      echo "${CMDNAME}: Unknown option: $1" 1>&2
      usage 1>&2
      exit 1
      ;;
  esac
done

# Check release type
if [[ -z "$RELEASE_TYPE" ]]; then
  echo "${CMDNAME}: Release type (minor or patch) is required." 1>&2
  usage 1>&2
  exit 1
fi

# Check required commands
if ! type 'git' > /dev/null 2>&1; then
  echo "${CMDNAME}: Git command not found." 1>&2
  exit 1
fi

if ! type 'gh' > /dev/null 2>&1; then
  echo "${CMDNAME}: GitHub CLI (gh) not found. Please install it first." 1>&2
  exit 1
fi

# Check if VERSION file exists
if [[ ! -f "$VERSION_FILE" ]]; then
  echo "${CMDNAME}: ${VERSION_FILE} file not found." 1>&2
  exit 1
fi

# Read current version
CURRENT_VERSION=$(cat "$VERSION_FILE" | tr -d '[:space:]')
if [[ ! "$CURRENT_VERSION" =~ ^0\.[0-9]+\.[0-9]+$ ]]; then
  echo "${CMDNAME}: Invalid version format in ${VERSION_FILE}: ${CURRENT_VERSION}" 1>&2
  echo "${CMDNAME}: Expected format: 0.x.y" 1>&2
  exit 1
fi

# Parse version components
IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

# Calculate new version
if [[ "$RELEASE_TYPE" == "minor" ]]; then
  NEW_MINOR=$((MINOR + 1))
  NEW_PATCH=0
  NEW_VERSION="0.${NEW_MINOR}.${NEW_PATCH}"
elif [[ "$RELEASE_TYPE" == "patch" ]]; then
  NEW_MINOR=$MINOR
  NEW_PATCH=$((PATCH + 1))
  NEW_VERSION="0.${NEW_MINOR}.${NEW_PATCH}"
fi

TAG_NAME="v${NEW_VERSION}"

# Check if tag already exists
if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
  echo "${CMDNAME}: Tag ${TAG_NAME} already exists." 1>&2
  exit 1
fi

# Check if working directory is clean (except for VERSION file)
if [[ -n "$(git status --porcelain | grep -v "^ M ${VERSION_FILE}$" | grep -v "^??")" ]]; then
  echo "${CMDNAME}: Working directory has uncommitted changes." 1>&2
  echo "${CMDNAME}: Please commit or stash them before releasing." 1>&2
  exit 1
fi

# Show release info
echo "Current version: ${CURRENT_VERSION}"
echo "New version: ${NEW_VERSION}"
echo "Tag: ${TAG_NAME}"
echo "Release type: ${RELEASE_TYPE}"
echo

# Confirm (skip in CI mode)
if [[ $CI_MODE == $FALSE ]]; then
  read -p "Create release ${TAG_NAME}? (y/n): " confirm
  if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
    echo "${CMDNAME}: Release cancelled."
    exit 0
  fi
fi

# Update VERSION file
echo "$NEW_VERSION" > "$VERSION_FILE"

# Commit version update
git add "$VERSION_FILE"
git commit -m "chore(release): ${NEW_VERSION}"

# Create Git tag
git tag -a "$TAG_NAME" -m "Release ${TAG_NAME}"

# Push commits and tags
git push origin HEAD
git push origin "$TAG_NAME"

# Create GitHub Release
# Get commits since last tag for release notes
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null | grep -v "^${TAG_NAME}$" | head -1 || echo "")
if [[ -z "$LAST_TAG" ]]; then
  NOTES="Release ${NEW_VERSION}"
else
  NOTES=$(git log "${LAST_TAG}..HEAD" --pretty=format:"- %s (%h)" | head -30)
  if [[ -z "$NOTES" ]]; then
    NOTES="Release ${NEW_VERSION}"
  fi
fi

gh release create "$TAG_NAME" \
  --title "$TAG_NAME" \
  --notes "$NOTES" \
  --target HEAD

echo
echo "Release ${TAG_NAME} created successfully!"
echo "Version updated from ${CURRENT_VERSION} to ${NEW_VERSION}"

exit 0

