#!/bin/bash

# Constant
readonly CMDNAME=${0##*/}
readonly VERSION='1.0.0'
readonly TRUE=1
readonly FALSE=0


function usage() {
  cmdname_space=$(echo $CMDNAME | sed -e "s/./ /g")

  cat << __USAGE_TEXT__
Usage:
  $CMDNAME
  $CMDNAME [-v] [-h]
__USAGE_TEXT__
}


function description() {
  cat << __DESCRIPTION_TEXT__
Description:
  Delete zsh history entries containing the specified string.
  The search string is read interactively from standard input.

Example:
  $ ${CMDNAME}
    * Prompts for search string interactively

Options:
  -h Show help
  -v Show version
__DESCRIPTION_TEXT__
}


function show_help() {
  usage
  echo
  description
}


# Option analysis
while getopts hv OPT
do
  case $OPT in
    "h" ) show_help >&1
          exit 0
          ;;
    "v" ) echo "$CMDNAME $VERSION"
          exit 0
          ;;
    # Invalid options
      * ) usage 1>&2
          exit 1 ;;
  esac
done
# Trim options from $*
shift $(($OPTIND - 1))


# Check if running in zsh or bash
if [[ -z "$HISTFILE" ]]; then
  HISTFILE="${HOME}/.zsh_history"
fi

if [[ ! -f "$HISTFILE" ]]; then
  echo "$CMDNAME: History file not found: $HISTFILE" 1>&2
  exit 1
fi


# Read search string interactively from standard input
# This prevents the command from being saved in history
read -p "Enter search string to delete from history: " search_string
if [[ -z "$search_string" ]]; then
  echo "$CMDNAME: Empty search string provided." 1>&2
  exit 1
fi


# Create backup
backup_file="${HISTFILE}.backup.$(date +%Y%m%d_%H%M%S)"
cp "$HISTFILE" "$backup_file"
if [[ $? -ne 0 ]]; then
  echo "$CMDNAME: Failed to create backup." 1>&2
  exit 1
fi
echo "Backup created: $backup_file"


# Find matching entries (handling multiline commands)
# First, combine multiline commands into single entries
temp_combined=$(mktemp)
LC_ALL=C awk -v search_string="$search_string" '
  BEGIN {
    entry_start = 0
    entry_lines = ""
    entry_count = 0
    prev_line = 0
  }
  {
    # Check if this line starts a new entry (format: : timestamp:duration;command)
    # Use match() to handle lines that may have trailing backslashes
    if (match($0, /^:[0-9]+:[0-9]+;/)) {
      # Save previous entry if exists
      if (entry_start > 0) {
        entry_count++
        entries[entry_count] = entry_lines
        entry_starts[entry_count] = entry_start
        if (prev_line > 0 && prev_line >= entry_start) {
          entry_ends[entry_count] = prev_line
        } else {
          entry_ends[entry_count] = entry_start
        }
      }
      # Start new entry
      entry_start = NR
      entry_lines = $0
    } else {
      # Continuation of previous entry
      if (entry_start > 0) {
        entry_lines = entry_lines "\n" $0
      } else {
        # Orphan line (should not happen in valid history file)
        entry_count++
        entries[entry_count] = $0
        entry_starts[entry_count] = NR
        entry_ends[entry_count] = NR
        entry_start = NR
        entry_lines = $0
      }
    }
    prev_line = NR
  }
  END {
    # Save last entry
    if (entry_start > 0) {
      entry_count++
      entries[entry_count] = entry_lines
      entry_starts[entry_count] = entry_start
      entry_ends[entry_count] = NR
    }
    
    # Find matching entries
    # Use index() for literal string matching (more reliable than regex)
    for (i = 1; i <= entry_count; i++) {
      if (index(entries[i], search_string) > 0) {
        matching[++match_count] = i
      }
    }
    
    # Output matching entries info (for display)
    for (i = 1; i <= match_count; i++) {
      idx = matching[i]
      print "MATCH:" entry_starts[idx] ":" entry_ends[idx] ":" entries[idx]
    }
    
    # Output all entries with match flags (for deletion)
    for (i = 1; i <= entry_count; i++) {
      is_match = 0
      for (j = 1; j <= match_count; j++) {
        if (matching[j] == i) {
          is_match = 1
          break
        }
      }
      if (!is_match) {
        print entries[i]
      }
    }
  }
' "$HISTFILE" > "$temp_combined"

if [[ $? -ne 0 ]]; then
  echo "$CMDNAME: Failed to process history file." 1>&2
  rm "$temp_combined" "$backup_file"
  exit 1
fi

# Extract matching entries
matching_entries=$(grep "^MATCH:" "$temp_combined")
match_count=$(echo "$matching_entries" | grep -c . || echo "0")

if [[ "$match_count" -eq 0 ]]; then
  echo "No matching entries found for: $search_string"
  rm "$temp_combined" "$backup_file"
  exit 0
fi

echo
echo "Found $match_count matching entr$(if [[ $match_count -eq 1 ]]; then echo "y"; else echo "ies"; fi) containing: $search_string"
echo
echo "Matching entries:"
echo "-----------------"

# Display matching entries
echo "$matching_entries" | while IFS= read -r line; do
  # Extract entry (format: MATCH:start:end:entry)
  entry=$(echo "$line" | sed 's/^MATCH:[0-9]*:[0-9]*://')
  # Extract command part after the first semicolon
  command_part=$(echo "$entry" | sed -n 's/^:[^:]*:[^;]*;\(.*\)$/\1/p')
  if [[ -n "$command_part" ]]; then
    # Count lines in command
    line_count=$(echo "$command_part" | wc -l | tr -d ' ')
    if [[ "$line_count" -gt 1 ]]; then
      # Show first few lines for multiline commands
      first_lines=$(echo "$command_part" | head -3)
      echo "  ${first_lines}"
      if [[ "$line_count" -gt 3 ]]; then
        echo "  ... (${line_count} lines total)"
      fi
    else
      echo "  $command_part"
    fi
  else
    echo "  $entry"
  fi
done

echo "-----------------"
echo

# Confirm deletion
read -p "Delete these entries? (y/n): " confirm
if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
  echo "$CMDNAME: Operation cancelled."
  rm "$temp_combined" "$backup_file"
  exit 0
fi

# Delete matching entries
# Extract lines to keep (entries not matching search string)
temp_file=$(mktemp)
grep -v "^MATCH:" "$temp_combined" > "$temp_file"

if [[ $? -ne 0 ]]; then
  echo "$CMDNAME: Failed to filter history." 1>&2
  rm "$temp_file" "$temp_combined" "$backup_file"
  exit 1
fi

mv "$temp_file" "$HISTFILE"
if [[ $? -ne 0 ]]; then
  echo "$CMDNAME: Failed to update history file." 1>&2
  rm "$temp_file" "$temp_combined" "$backup_file"
  exit 1
fi

rm "$temp_combined"

echo "Deleted $match_count entr$(if [[ $match_count -eq 1 ]]; then echo "y"; else echo "ies"; fi) from history."
echo "Backup saved at: $backup_file"


exit 0
